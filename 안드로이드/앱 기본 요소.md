## 안드로이 기본 요소

### 안드로이드 보안 기능

- Android os는 멀티유저 Linux 시스템으로, 각 앱은 다른 사용자와 같다
- 시스템이 각 앱에 고유한 Linux ID를 할당한다
  - 이 ID는 시스템에서만 사용 가능, 앱에서는 인식x
  - 시스템 앱 안의 모든 파일에 대해 권한을 설정하여 해당 앱에 할당된 사용자만 ID에 액세스 가능
- 각 프로세스에는 자체적인 VM(가상머신)이 있다
  - 앱의 코드가 다른 앱과는 격리된 상태로 실행
- 앱 자체의 Linux 프로세스에서 실행



### 최소 권한의 원리 

각 앱은 기본적으로 자신의 작업을 수행하기 위해 필요한 구성 요소에만 액세스 권한을 가지고 그 이상은 허용되지 않는다. 시스템에서 권한을 부여받지 못한 부분에 대해서는 접근이 허용되지 않는다. 앱이 다른앱과 데이터를 공유하고 시스템 서비스에 액세스 하는 방법은 여러가지가 있다.

- 두개의 앱이 같은 Linux 사용자 ID를 공유하게 설정할 수 있다.
  - 서로의 리소스에 액세스 가능
  - 같은 VM을 공유하도록 설정가능
  - 인증서로 서명해야함
- 앱은 데이터에 액세스할 권한을 요청할 수 있다.
  - 이러한 권한을 명시적으로 부여해야한다



### 앱 구성 요소 (4대 컴포넌트)

Android 앱의 필수적인 기본구성요소 이며 앱을 정의하는 핵심 프레임 워크. 각 구성요소는 시스템이나 사용자가 앱에 들어올 수 있는 진입점이다. 각 구성요소는 인텐트를 통해 상호 통신을 한다.

- Actvity
- Service
- Broadcast Recevier
- Content Provider

뚜렷한 목적을 수행하고 각자 나름의 수명 주기를 가져 구성요소의 생성 및 소멸 방식을 정의



#### Activity

- 사용자와 상호 작용하기 위한 진입점으로 UI(사용자 인터페이스)를 포함한 화면 하나를 나타낸다.
- 여러 액티비티가 함께 작동하여 짜임새 있는 사용자 환경을 구성하고 서로 독립되어있다.

- 사용자가 현재 관심을 가지고 있는 사항을 추적하여 액티비티를 호스팅하는 프로세스를 시스템에서 계속 실행
- 이전에 사용한 프로세스에 사용자가 다시 찾을만한 액티비티(중단된 액티비티)가 있다는 것을 알고, 해당 프로세스를 유지하는데 더 높은 우선순위를 부여
- 앱이 프로세스를 종료하도록 도와서 이전 상태가 복원되는 동시에 사용자가 액티비티로 돌아 갈 수 있게함
- 앱이 서로 사용자 플로우를 구현하고 시스템이 이러한 플로우를 조정하기 위한 수단을 제공



#### Service

- 백그라운드에서 앱을 계속 실행하기 위한 다목적 진입점. 
- 백그라운드에서 실행되는 구성요소로써 오랫동안 실행되는 작업을 수행하거나 원격 프로세스를 위한 작업을 수행한다.
- UI를 제공하지 않는다. 
- 다른 구성요소가 서비스를 시작한 다음 실행되도록 두거나 자신에게 바인딩하여 상호작용을 할 수도 있게 한다.

- 시작된 서비스는 작업이 완료 될 때까지 해당 서비스를 계속 실행하라고 시스템에게 지시
  - 백그라운드에서 일부 데이터를 동기화 하거나 사용자가 앱에서 나간 후에도 음악을 재생하는 서비스

- 시스템에서 Service를 처리하는 두 가지 방식
  - 사용자가 바로 인식할 수 있는 작업 (ex. 음악 재생)
    - 앱은 사용자에게 이와 관련된 알림을 보내고 음악 재생을 포그라운드로 옮기라고 시스템에 지시(?????)
    - 서비스의 프로세스가 계속 실행되도록 많은 노력을 기울여야함
  - 정기적인 백그라운드 서비스는 사용자가 직접 인식할 수 없는 작업이므로 시스템이 자유롭게 프로세스 관리 가능
    - 사용자와 좀 더 직접적인 관련이 있는 작업에서 RAM이 더 필요할 경우 이 서비스 종료 가능
      - 나중에 재시작
- 바인딩된 서비스는 다른 앱에서 서비스를 사용하고 싶다는 의향을 표현했기 때문에 실행
  - 서비스가 다른 프로세스에게 API를 제공
  - 시스템은 프로세스 사이에 종속성이 있는지 알게 됨
  - 프로세스 A가 프로세스 B의 서비스에 바인딩 되어 있을 경우 A를 실행 후 B를 실행해야함
- Android 5.0(API 레벨 21)이상을 대상으로 하는 경우 JobScheduler클래스를 사용하여 작업 예약
  - 작업 일정을 최적으로 조정하여 전력 소모량을 줄이고 Doze API와 함께 동작하여 배터리 절약



#### Broadcast Receiver

- 시스템이 정기적인 사용자 플로우 밖에서 이벤트를 앱에 전달하도록 지원하는 구성요소
- 앱이 시스템 전체의 브로드캐스트 알림에 응답할 수 있게 함
- 현재 실행되지 않은 앱에도 시스템이 브로드캐스트를 전달할 수 있다.
  - 알림이 울릴 때까지 앱을 실행 할 필요가 없다.
- 화면 꺼짐, 사진을 캡쳐 했다고 알리는 서비스  >> 브로드캐스트이용 서비스
- 사용자 인터페이스를 표시하지 않지만, `상태표시줄 알림`을 생성하여 이벤트 발생 여부를 알려줌
- 게이트웨이 인 경우 더 보편적이고, 극소량의 작업만 수행 할 수 있도록 만들어진 경우가 있다. (????)
  - JobService를 예약하여 시작하여 JobScheduler가 포함된 이벤트를 기초로 어떤 작업을 수행할 수 있게 할 수 있다.



#### Content Provider

- 파일시스템, SQLite, 웹 상이나 앱이 액세스 할 수 있는 다른 모든 영구 저장 위치에 저장가능한 앱 데이터의 공유형 집합
- 콘텐츠 제공자를 통해 데이터를 쿼리하거나, 콘텐츠 제공자가 허용할 경우 수정 가능
- 적절한 권한을 가진 앱이면 콘텐츠 제공자를 쿼리하여 특정한 인물에 대한 정보를 읽고 쓸 수 있다.
- URI 구성표로 식별되고 이름이 지정된 데이터 항목을 게시할 목저으로 앱에 진입하기 위한 입구
- URI 네임스페이스에 넣을 데이터를 매핑할 방식을 결정하고 해당 URI를 다른 엔터티에 전달 하 ㄹ수 있다.
- 전달 받은 엔터티는 URI를 사용하여 데이터에 액세스
  - URI를 할당하더라도 앱을 계속 실행할 필요가 없으므로 URI를 소유한 앱이 종료된 후에도 URI를 유지 할 수 있다.
  - URI는 중요하고 조밀한 보안 모델 제공
    - 클립보드 이미지에 URI를 할당하고 콘텐츠 제공자가 검색하도록 하여 다른앱이 자유롭게 이미지에 액세스 하지 못하게 막을 수 있다.
    - 임시 URI권한을 부여하여 앱이 데이터에 액세스 하도록 허용할 수 있다.
- 앱 전용이어서 공유되지 않는 데이터를 읽고 쓰는데 유용함





Anroid 시스템 디자인은 어떤 앱이든 다른 앱의 구성요소를 시작할 수 있다는 점에서 독특하다.

- 사용자가 기기 카메라로 사진을 캡처하기 바라는 경우, 그런 작업을 수행하는 다른 앱이 있을 가능 성이높다. 사진 캡처 액티비티를 직접 개발하는 대신 그 작업을 수행하는 앱을 사용하면된다!



시스템이 구성요소를 시작할 떄 그 앱에 대한 프로세스를 시작하고, 해당 구성 요소에 필요한 클래스를 인스턴스화 한다.

- 카메라 앱 내에서 사진을 캡처하는 액티비티를 시작하면, 해당 액티비티는 앱 프로세스가 아니라 카메라 앱에 속한 프로세스에서 실행
- Android앱은 단일한 진입점이 없다(main 함수)



다른 앱에 있는 구성요소를 활성화하려면 시스템에 메세지를 전달하여 특정 구성요소를 시작하고자하는 `인텐트`를 밝혀야한다. 그럼 시스템이 대신 해당 구성 요소를 활성화 한다.





### 구성요소의 활성화

- `인텐트`라는 비동기식 메세지로 활성화
- 인텐트 : 런타임에서 각 구성요소를 서로 바인딩하는 것
- Intent 객체로 생성
- 명시적 인텐트와 암시적 인텐트로 나뉨
  - 명시적 인텐트 : 특정 구성요소를 활성화 하는 것
    - 사용할 구성요소를 명시적으로 명명
    - 구성요소 클래스 이름 사용
  - 암시적 인텐트 : 구성요소의 특정 유형을 활성화 할지
    - 수행할 작업의 유형을 설명
    - 시스템이 작업을 수행할 수 있는 기기에서 구성요소를 찾아 작업을 시작할 수 있다.
- Activity와 Service의 경우 `수행할 작업을 정의`하며, 시작되는 구성 요소가 알야하 할 것이 많다.
  - 작업을 수행할 데이터의 URI 지정 가능
  - 액티비티에 이미지를 표시하거나 웹페이지를 열라는 요청 가능
  - 결과르르 수신하기 위해 액티비티를 시작할 수 있다.
- Broadcast Receiver의 경우 `브로드캐스트 될 알림을 정의` 
  - 기기 배터리 잔량이 낮다는 것을 나타내는 브로드캐스트에는 배터리 부족을 나타내는 알려진 작업 문자열만 포함
- Content Provider의 경우 `인텐트로 활성화 되지 않는다`.
  - ContentResolver가 보낸 요청의 대상으로 지정되면 활성화.
  - 콘텐츠 확인자는 콘텐츠 제공자와 모든 직접적인 트랜잭션을 처리하여 제공자와 트랜잭션을 수행하는 구성요소가 그런 처리를 하지 않는 대신 Content Resolver객체에서 메서드를 호출하게 한다.
  - 콘텐츠 제공자와 정보를 요청하는 구성요소 사이에 추상화 계층이 하나 남음
- 각 구성요소가 Intent를 활성하 하는 메소드
  - Activity : startActivity(), startActivityForResult()
  - Service : startService(), bindService() >> 초기 버전
    - JobScheduler클래스를 사용하여 작업을 예약할 수 있다.
  - Boradcast Receiver : sendBraodcast(), sendOrderBraodcast(), sendStickyBroadcast()
  - Content Provider : ContentResolver에서 query()호출
- 인텐트를 사용하여 Service를 바인딩 할 경우 `명시적 인텐트`사용하여 앱을 보호해야함
  - 암시적 인텐트를 사용하여 서비스를 시작하면 보안 위험 초래
  - 어느 서비스가 응답할 것인지 확신할 수 없고, 사용자는 어느 서비스가 시작되는지 볼 수 없기 때문에
  - Android 5.0(API 21)부터 시스템은 개발자가 암시적 인텐트로 bindService()를 호출하면 예외 발생
  - 서비스에 대한 인텐트 필터를 선언하면 안됌



### Manifest 

Android 시스템이 앱 구성요소를 시작하려면 Manifest 파일을 읽어 해당 구성요소가 존재하는 지 확인해야한다. 앱은 Manifest에 모든 구성요소를 선언해야하며, 프로젝트 루트에 존재해야한다.

- 앱 요구사항(기기, 소프트웨어)을 Manifest에 모두 선언 >> 앱에 대한 명확한 포로필 정의

- 앱이 요구하는 모든 사용자 권한을 식별
- 앱이 어느 API를 사용하는지 근거로 앱에서 요구하는 `최소 API레벨`을 선언
- 앱에서 사용하거나 요구하는 하드웨어 및 소프트웨어 기능 선언
- 앱이 링크되어야 하는 API 라이브러리(Android 프레임 워크 API 제외)선언
- 각 구성요소의 선언
  - Activity : < activity >
  - Service :  < service > 
  - Boradcast Receiver : < receiver >
  - Content Provider : < provider >
- Broadcast Receiver는 매니페스트에서 선언해도 되고 코드를 사용해 동적으로 생성한 뒤 시스템에 등록해도 됨
  - registerReceiver()호출



### Intetn와 Manifest

- 인텐트 필터와 수신된 인텐트를 비교하는 방법으로 인텐트에 응답할 수 있는 구성요소를 식별
- 인텐트 필터 더 알아 보기





