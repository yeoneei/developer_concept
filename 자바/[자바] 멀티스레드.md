#  Multi Thread

### 멀티 스레드 개념

- 프로세스와 스레드
  - 프로세스 : 실행 중인 하나의 애플리케이션
  - 멀티 쓰레드 : 하나의 Process가 두 가지 이상의 작업을 처리할 수 있ㄷ록 하는 것
- 메인 스레드
  - 자바 애플리케이션은 매인 스레드가 main() 메소드를 실행하면서 실행
  - 메인 스레드에서 다른 작업의 스레드들을 만들어 실행할 수 있으며, 모든 스레드가 종료되어야 프로세스가 종료된다.



### 작업 스레드 생성과 실행

- `java.lang.Thread` 클래스로부터 직접 생성
  - Runnnable 인터페이스를 implements한다.
  - run() 메소드에 스레드가 실행할 코드를 작성한다.

```java
public class Task implements Runnable{
    public void run(){
        // 스레드가 실행할 코드;
    }
}
```

```java
Runnable task = new Task();
Thread thread = new Thread(task);
```

- 익명 구현 객체를 사용하는 방법

```java
Thread thread = new Thread(new Runnable(){
    public void run(){
        // 스레드가 실행할 코드;
    }
});
```

- Java8의 람다식을 사용하는 방법

```
Thread thread = new Thread(()->{
    // 스레드가 실행할 코드;
});
```

- Thread 시작

```java
thread.start();
```

- Thread 클래스 상속 후 run() 메소드 재정의

```java
public class myThread extends Thread{
    @Override
    public void run(){
        // 스레드가 실행할 코드
    }
}
```

- 익명개체로도생성가능
- 스레드 이름 
  - Thread 클래스의 setName("스레드 이름")메소드를 사용해서 변경하면 된다.
- 현재 스레드의 객체 참조를 얻는 방법

```java
Thread thread = Thread.currentThread();
```



### 스레드의 우선 순위

- 동시성(Currency) : 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아서 실행
- 병렬성(Parallesim) : 멀티 작업을 위해 멀티 코어에서 각각의 스레드를 동시에 실행
- 스레드 스케쥴링 : 코어의 수 < 스레드 수 인경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것인가 결정 하는 것
  - 우선순위 방식
    - 우선순위가 높은 스레드가 더 많이 실행 상태를 가지도록 하는 것
    - 개발자가 우선 순위번호를 `thread.setPriority(int);`으로 부여가능
      - 1 (낮음) ~ 5 (기본) ~ 10 (높음)
  - 순환 활당(Round-Robin) 방식
    - 시간 할당량(Time Slice)를 정해서 정해진 시간만큼만 각각의 스레드를 실행 시키는 방법
    - JVM에 의해서 정해지기 때문에 제어 불가능



### 동기화 메소드와 동기화 블록

- 공유 객체를 사용할 때 주의 점
  - 멀티 스레드 애플리케이션의 경우 스레드들이 객체를 공유해서 작업하는 경우 문제가 생길 수 있음
- 스레드가 사용중인 객체를 다른 스레드가 변경할 수 없도록 객체에 잠금을 걸어야 한다 synchronzied 키원드를 사용하여 동기화 블록을 만든 후 단 하나의 스레드만 실행되도록 하면 만들어 주면 된다.

```java
public synchronized void method(){
    // 단 하나의 스레드만 실행 가능
}
```

```java
public void method(){
    // 여러 스레드가 실행 가능
    synchronized(공유객체){
        // 단 하나의 스레드만 실행 가능
    }
    // 여러 스레드가 실행 가능
}
```



### 스레드 상태

- 객체 생성 -> start() 메소드 호출 -> 실행 대기 상태 (스케줄링이 되지 않아서 실행을 기다림) -> 실행 상태(스케줄링으로 선택된 스레드가 CPU를 점유하고 run() 메소드 실행) -> 실행 대기와 실행 상태를 반복하면서 run()메소드를 조금씩 실행하여 run()메소드 종료 -> 종료



### 스레드 상태 제어

- sleep() : 주어진 시간동안 일시 정지, interruptedException 발생
- yield() : 다른 스레드에게 실행 양보
  - `실행 대기 상태`로 돌아가게 되고, 동일한 우선순위 또는 높은 우선순위를 ㅏㄱ즌ㄴ 다른 스레드가 실행 기회를 가질 수 있게 해준다.
- join() : 다른 스레드가 종료 될 때 까지 기다렸다가 실행



### 스레드간의 협업

- Object 클래스의 메소드이므로, 모든 공유 객체에서 호출 가능하고, 동기화 메소드 또는 동기화 블록 내에서만 사용가능하다
- notify() : wait()에 의해서 일지 성지 된 스레드 중 한개를 실행 대기 상태로 만든다.
- notifyAll() : wait()에 의해서 일시 정지된 모든 스레드 들을 실행 대기 상태로 만든다.
- wait() : 자신을 일시 정지 상태로 만든다



### 스레드의 안전한 종료

- stop 플래그와 interrupt 메소드
  - stop : setStop(true)



### 데몬 스레드

- 주 스레드의 작업을 돕는 보조적인 역할 수행
- 주 스레드가 종료되면 데몬 스레드는 강제적 종료



### 스레드 그룹

- JVM이 실행되면 JVM 운영에 필요한 스레드들을 생성해서 system 스레드 그룹에 포함시키고, system의 하위 스레드 그룹으로 main을 만들고 main스레드 그룹에 포함시킨다.



### 스레드풀

- 갑작스런 병렬작업의 증가로 인한 스레드의 폭증을 막기 위해서는 스레드풀(ThreadPool)을 사용해야한다.
- Thread Pool은 작업 처리에 사용되는 Thread를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 Thread가 맡아 처리
  - 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리
- `ExecuteorService`인터페이스와 ExecutorService 구현 객체를 만들수 있는 `Executors` 클래스 제공

- 스레드풀은 기본적으로 데몬 스레드가 아니기 때문에 main 스레드가 종료되더라도 계속 실행 상태로 남아 있다.
  - 종료시키는 작업을 해줘야한다.

